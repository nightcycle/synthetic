"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[9671],{3905:function(t,e,n){n.d(e,{Zo:function(){return u},kt:function(){return d}});var o=n(67294);function i(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}function a(t,e){var n=Object.keys(t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);e&&(o=o.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),n.push.apply(n,o)}return n}function r(t){for(var e=1;e<arguments.length;e++){var n=null!=arguments[e]?arguments[e]:{};e%2?a(Object(n),!0).forEach((function(e){i(t,e,n[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(n,e))}))}return t}function l(t,e){if(null==t)return{};var n,o,i=function(t,e){if(null==t)return{};var n,o,i={},a=Object.keys(t);for(o=0;o<a.length;o++)n=a[o],e.indexOf(n)>=0||(i[n]=t[n]);return i}(t,e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(t);for(o=0;o<a.length;o++)n=a[o],e.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(t,n)&&(i[n]=t[n])}return i}var s=o.createContext({}),c=function(t){var e=o.useContext(s),n=e;return t&&(n="function"==typeof t?t(e):r(r({},e),t)),n},u=function(t){var e=c(t.components);return o.createElement(s.Provider,{value:e},t.children)},p={inlineCode:"code",wrapper:function(t){var e=t.children;return o.createElement(o.Fragment,{},e)}},h=o.forwardRef((function(t,e){var n=t.components,i=t.mdxType,a=t.originalType,s=t.parentName,u=l(t,["components","mdxType","originalType","parentName"]),h=c(n),d=i,y=h["".concat(s,".").concat(d)]||h[d]||p[d]||a;return n?o.createElement(y,r(r({ref:e},u),{},{components:n})):o.createElement(y,r({ref:e},u))}));function d(t,e){var n=arguments,i=e&&e.mdxType;if("string"==typeof t||i){var a=n.length,r=new Array(a);r[0]=h;var l={};for(var s in e)hasOwnProperty.call(e,s)&&(l[s]=e[s]);l.originalType=t,l.mdxType="string"==typeof t?t:i,r[1]=l;for(var c=2;c<a;c++)r[c]=n[c];return o.createElement.apply(null,r)}return o.createElement.apply(null,n)}h.displayName="MDXCreateElement"},59881:function(t,e,n){n.r(e),n.d(e,{frontMatter:function(){return l},contentTitle:function(){return s},metadata:function(){return c},toc:function(){return u},default:function(){return h}});var o=n(87462),i=n(63366),a=(n(67294),n(3905)),r=["components"],l={sidebar_position:1},s=void 0,c={unversionedId:"intro",id:"intro",isDocsHomePage:!1,title:"intro",description:"Installation",source:"@site/docs/intro.md",sourceDirName:".",slug:"/intro",permalink:"/synthetic/docs/intro",editUrl:"https://github.com/nightcycle/synthetic/edit/master/docs/intro.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"defaultSidebar",next:{title:"contributing",permalink:"/synthetic/docs/contributing"}},u=[{value:"Installation",id:"installation",children:[],level:2},{value:"Components",id:"components",children:[{value:"Using within Studio",id:"using-within-studio",children:[],level:3},{value:"Constructing Components",id:"constructing-components",children:[],level:3}],level:2},{value:"Passing State to Components",id:"passing-state-to-components",children:[{value:"Properties",id:"properties",children:[],level:3},{value:"Events",id:"events",children:[],level:3},{value:"Functions",id:"functions",children:[],level:3},{value:"Typography",id:"typography",children:[],level:3},{value:"Adding Custom Components",id:"adding-custom-components",children:[],level:3}],level:2},{value:"Useful Tools",id:"useful-tools",children:[],level:2}],p={toc:u};function h(t){var e=t.components,n=(0,i.Z)(t,r);return(0,a.kt)("wrapper",(0,o.Z)({},p,n,{components:e,mdxType:"MDXLayout"}),(0,a.kt)("h2",{id:"installation"},"Installation"),(0,a.kt)("p",null,"Add to your wally.toml file the synthetic release listed here: ",(0,a.kt)("a",{parentName:"p",href:"https://github.com/UpliftGames/wally-index/tree/main/nightcycle"},"https://github.com/UpliftGames/wally-index/tree/main/nightcycle")),(0,a.kt)("p",null,"If you don't use wally this is your wake-up call to do so, however for those who don't want to go through the install process I'll be uploading a RBXM file whenever I make an announcement on the DevForum."),(0,a.kt)("h2",{id:"components"},"Components"),(0,a.kt)("h3",{id:"using-within-studio"},"Using within Studio"),(0,a.kt)("p",null,"As you may have guessed, in order to use this UI library on the client you need to require it on the client. Unlike most UI libraries, Synthetic also needs to be required by the server - this is because of the text filtering server dependencies. I might eventually update the relevant dependencies so this is not the case."),(0,a.kt)("h3",{id:"constructing-components"},"Constructing Components"),(0,a.kt)("p",null,"To construct a Synthetic component you go about it the same was as with Fusion."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'local synthetic = require(modulePath)\n\n-- More readable, clearly shows how the first function returns a constructor\nlocal buttonConstructor = synthetic.New("Button")\nlocal button = buttonConstructor({\n    Text = "Click me!"\n})\n\n-- More compact, easier to nest in a configuration table\nlocal button2 = synthetic.New("Button")({\n    Text = "Click me!"\n})\n\n-- Most compact: it turns out you don\'t need parentheses to call a function\nlocal button3 = synthetic.New "Button" {\n    Text = "Click me!"\n}\n')),(0,a.kt)("h2",{id:"passing-state-to-components"},"Passing State to Components"),(0,a.kt)("p",null,"Like with Fusion, you can pass state and even Fusion flags through a Synthetic constructor, they'll"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'local synthetic = require(modulePath)\nlocal _Text = fusion.State("Click me!")\nlocal button = synthetic.New "Button" {\n    Text = _Text,\n    [fusion.OnChange "Activated"] = function()\n        _Text:set("I was clicked") --should change text on button\n    end,\n}\n')),(0,a.kt)("h3",{id:"properties"},"Properties"),(0,a.kt)("p",null,"Attributes are meant to serve as custom public-facing properties, allowing you easy configuration at later points using other scripts. Any non read-only property listed in the API will have an associated internal state that can be read from and written by changing the associated attribute."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'-- construction script\nlocal synthetic = require(modulePath)\nlocal _Input = fusion.State(false) -- it will be off upon construction\nlocal switch = synthetic.New "Switch" {\n    Input = _Input,\n}\n\n-- other script\nlocal switch = gui:WaitForChild("Switch")\nswitch:SetAttribute("Input", true) --should change the _Input state above to match\nlocal currentSwitch = switch:GetAttribute("Input") --gets the current _Input value, not _Input itself\n\n-- creating a mirroring State, though it will take a frame to update it and is a bit messy\nlocal _InputMirror = fusion.State(false)\nlocal maid = maidConstructor.new() --if you don\'t have a maid library, please get one. I use Quenty\'s\nmaid:GiveTask(currentSwitch:GetAttributeChangedSignal("Input"):Connect(function(val)\n    _InputMirror:set(currentSwitch:GetAttribute("Input"))\nend))\n')),(0,a.kt)("p",null,"If you wish to keep a variable private, simply remove the attribute after construction but before you parent it."),(0,a.kt)("h3",{id:"events"},"Events"),(0,a.kt)("p",null,"Various components also include BindableEvents which you may use as signal constructors."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'local synthetic = require(modulePath)\nlocal dialog = synthetic.New "Dialog" {\n    Button1Text = "No",\n    Button2Text = "Yes",\n}\ndialog.OnSelect:Connect(function(buttonText) --WaitForChild might be safer\n    print("This was the button text of the selected button: ", buttonText)\nend)\n')),(0,a.kt)("h3",{id:"functions"},"Functions"),(0,a.kt)("p",null,"BindableEvents and BindableFunctions are both used to simulate calling a function on a component, with the main difference being if the function returns something it uses a BindableFunction"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},"local synthetic = require(modulePath)\nlocal display = synthetic.New \"Display\" {\n    CameraPosition = Vector3.new(0,0,-4),\n}\n\n--let's put the player character in it\nlocal playerCharacter = game.Players.LocalPlayer.Character\nor game.Players.LocalPlayer.CharacterAdded:Wait()\n\nlocal vfController = display.InsertHumanoid:Invoke(playerCharacter) --RemoteFunction\n\n--let's hide this for later\ndisplay.HideScene:Fire() --RemoteEvent\n")),(0,a.kt)("p",null,"I originally considered using just BindableFunctions to keep the API consistent between function calls, but I felt that the comparably slow nature of them (they take at least 2x as long as BindableEvents) would be unnecessarily limiting."),(0,a.kt)("p",null,"It can be tempting to make a pseudoclass wrapper for these kinds of functions and properties, and make them feel even more like regular native Roblox instances. Before you do that though, I ask that you consider what you may lose. In their current form any script or thread with access to the instance has full access to the functionality with no extra steps. This allows for more modular code, as well as encourages developers to create their components encapsulated. I think that's worth a bit of extra API."),(0,a.kt)("h3",{id:"typography"},"Typography"),(0,a.kt)("p",null,"Some of you will hate this, and I'm sorry about that. I've constructed a custom Typography class. This class is a FusionState table composed of 3 calculated properties: TextSize, Font, and Padding."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'local synthetic = require(modulePath)\nlocal font = Enum.Fonts.SourceSans\nlocal minTextSize = 10\nlocal maxTextSize = 14\nlocal _ButtonTypography = synthetic.newTypography(font, minTextSize, maxTextSize)\nlocal button = synthetic.New "Button" {\n    Text = "Test",\n    Typography = _Typography,\n}\n')),(0,a.kt)("p",null,"Based on the dimensions of a person's screen, the Typography will solve for an ideal TextSize that will be used consistently across all instances of that TypographyState. The TextSize is also consistently used in padding."),(0,a.kt)("p",null,"The benefits of using a set list of Typography across your UI is pretty compelling. For instance you could allow users with poor eyesite to increase the size of their text. The text scaling will also be consistent across UI components if you like. Finally, if you want to try out new fonts, it's very easy to check how it would all look. If Roblox ever supports custom font uploading, this library will certainly update to allow for that."),(0,a.kt)("h3",{id:"adding-custom-components"},"Adding Custom Components"),(0,a.kt)("p",null,"If you want to add a custom component to your game, all you need to do is init that constructor when the client starts."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre"},'local synthetic = require(modulePath)\n\nlocal key = "myNewComponent"\nfunction constructor(parameters: table | nil)\n    --construct whatever you want and return it\n    local inst\n    return inst --if you want to add public attributes check out Util.set in API\nend\n\nsynth.set(key, constructor)\n\n--any other script\nlocal inst = synth.New "myNewComponent"()\n')),(0,a.kt)("p",null,"Eventually I might add some functionality to query whether a component exists, for now just run it in a pcall if you're facing a racing condition."),(0,a.kt)("h2",{id:"useful-tools"},"Useful Tools"),(0,a.kt)("p",null,"Synthetic also has an Effects and a Util library, both of which could save you a bit of code in your own components. They aren't nearly as polished or well documented though, so use with caution. You can explore the exact methods available in their associated API pages."))}h.isMDXComponent=!0}}]);